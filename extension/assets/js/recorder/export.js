/* Author: Denis Podgurskii */
'use strict';
// ---------------------------------------------------------------------------
// Exporter -- a class to render recorded tests
// ---------------------------------------------------------------------------

var EventTypes = {};

EventTypes.OpenUrl = 0;
EventTypes.Click = 1;
EventTypes.Keypress = 2;
EventTypes.Paste = 12;


function Exporter() {
    this.title = "PenTestKit exporter";
    this.items = null;
    this.history = new Array();
    this.last_events = new Array();
    this.screen_id = 1;
    this.unamed_element_id = 1;
    this.output = '';
    this.useEncryption = true;
    this.minDuration = 0;
    this.elementPath = "";
    this.debug = false;
}

Exporter.prototype.stmt = function(text, indent) {
    if (indent == undefined) indent = 1;
    var output = (new Array(4 * indent)).join(" ") + text;
    this.output += text;
}

Exporter.prototype.pyrepr = function(text, escape) {
    // todo: handle non--strings & quoting
    // There should a more eloquent way of doing this but by  doing the escaping before adding the string quotes prevents the string quotes from accidentally getting escaped creating a syntax error in the output code.
    var s = text;
    if (escape) s = s.replace(/(['"])/g, "\\$1");
    var s = "'" + s + "'";
    return s;
}

var d = {};
d[EventTypes.OpenUrl] = "openUrl";
d[EventTypes.Click] = "click";
d[EventTypes.Keypress] = "keypress";
d[EventTypes.Paste] = "paste";

Exporter.prototype.dispatch = d;

var cc = EventTypes;

Exporter.prototype.renderXml = function(items, options) {
    this.output = '';
    this.items = items;
    var etypes = EventTypes;
    this.useEncryption = options['useEncryption'];
    this.minDuration = options['min_duration'];;
    this.elementPath = options['element_path'];
    this.writeHeader();
    var last_down = null;
    var forget_click = false;
    var lastItem = null;
    for (var i = 0; i < this.items.length; i++) {
        var item = this.items[i];
        lastItem = item;
        if (i == 0) {
            if (item.type != etypes.OpenUrl) {
                //this.stmt("ERROR: the recorded sequence does not start with a url openning.");
                this.output = 'error';
                return;
            } else {
                this.startUrl(item);
                this.delay(item);
                continue;
            }
        }

        if (this.debug) console.log(item.type);
        if (this.dispatch[item.type]) {
            this[this.dispatch[item.type]](item);
        }
    }
    if (lastItem != null) this.delay(lastItem);
    this.writeFooter();
    return this.output;
}

Exporter.prototype.formatXml = function(xml) {
    var formatted = '';
    var reg = /(>)(<)(\/*)/g;
    xml = xml.replace(reg, '$1\r\n$2$3');
    var pad = 0;
    jQuery.each(xml.split('\r\n'), function(index, node) {
        var indent = 0;
        if (node.match(/.+<\/\w[^>]*>$/)) {
            indent = 0;
        } else if (node.match(/^<\/\w/)) {
            if (pad != 0) {
                pad -= 1;
            }
        } else if (node.match(/^<\w([^>]*[^\/])?>.*$/)) {
            indent = 1;
        } else {
            indent = 0;
        }

        var padding = '';
        for (var i = 0; i < pad; i++) {
            padding += '  ';
        }

        formatted += padding + node + '\r\n';
        pad += indent;
    });

    return formatted;
}

Exporter.prototype.normalizeWhitespace = function(s) {
    return s.replace(/^\s*/, '').replace(/\s*$/, '').replace(/\s+/g, ' ');
}

Exporter.prototype.shortUrl = function(url) {
    return url.substr(url.indexOf('/', 10), 999999999);
}

Exporter.prototype.getControl = function(item) {
    var type = item.info.type;
    var tag = item.info.tagName.toLowerCase();
    var selector;
    if ((type == "submit" || type == "button") && item.info.value)
        selector = tag + '[type=' + type + '][value=' + this.pyrepr(this.normalizeWhitespace(item.info.value)) + ']';
    else if (item.info.name || item.info.id)
        selector = tag + '[@name="' + this.pyrepr(item.info.name) + '"]';
    else
        selector = item.info.selector;

    return selector;
}

Exporter.prototype.getLinkXPath = function(item) {
    var way;
    if (item.text)
        way = 'normalize-space(text())=' + this.cleanStringForXpath(this.normalizeWhitespace(item.text), true);
    else if (item.info.id)
        way = '@id=' + this.pyrepr(item.info.id);
    else if (item.info.href)
        way = '@href=' + this.pyrepr(this.shortUrl(item.info.href));
    else if (item.info.title)
        way = 'title=' + this.pyrepr(this.normalizeWhitespace(item.info.title));

    return way;
}

Exporter.prototype.GUID = function() {
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
            v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16).toUpperCase();
    });
}

Exporter.prototype.writeHeader = function() {
    this.stmt('<?xml version="1.0"?>\r\n', 0);
    this.stmt("<MacroEventList>\r\n", 0);
}

Exporter.prototype.writeFooter = function() {
    this.stmt("</MacroEventList>", 0);
}

Exporter.prototype.eventDuration = function(duration) {
    this.minDuration = parseInt(this.minDuration);
    duration = parseInt(duration);
    if (duration < this.minDuration) duration = this.minDuration + duration + (Math.floor(Math.random() * 111) + 1);
    return duration;
}

Exporter.prototype.elementPathByType = function(info) {
    if (this.elementPath == "fullpath") return info.fullxpath;
    if (this.elementPath == "javascript") return info.javascript;
    return info.xpath;
}

Exporter.prototype.startUrl = function(item) {
    this.template(item, 'Navigate', item.url, '');
}

Exporter.prototype.keypress = function(item) {
    this.template(item, 'SetControlData', item.text, this.elementPathByType(item.info));
}

Exporter.prototype.paste = function(item) {
    this.template(item, 'SetControlData', item.text, this.elementPathByType(item.info));
}

Exporter.prototype.click = function(item) {
    this.template(item, 'OnClick', (item.info.value != undefined ? item.info.value : ""), this.elementPathByType(item.info));
}

Exporter.prototype.delay = function(item) {
    this.template(item, 'Delay', '', '');
}

Exporter.prototype.template = function(item, event, data, path) {
    this.stmt("<MacroEvent>\r\n");
    this.stmt("   <DbId>" + this.GUID() + "</DbId>\r\n");
    this.stmt("   <ParentDbId>00000000000000000000000000000000</ParentDbId>\r\n");
    this.stmt("   <WindowIndex>0</WindowIndex>\r\n");
    this.stmt("   <EventType>" + event + "</EventType>\r\n");
    this.stmt("   <UseEncryptedData>" + ((item.info && item.info.type == "password" && this.useEncryption) ? 1 : 0) + "</UseEncryptedData>\r\n");
    this.stmt("   <Data><![CDATA[" + data + "]]></Data>\r\n");
    this.stmt("   <EncryptedData></EncryptedData>\r\n");
    this.stmt("   <ElementPath><![CDATA[" + path + "]]></ElementPath>\r\n");
    this.stmt("   <Duration>" + this.eventDuration(item.eventDuration) + "</Duration>\r\n");
    this.stmt("   <Enable>1</Enable>\r\n");
    this.stmt("   <Optional>0</Optional>\r\n");
    this.stmt("</MacroEvent>\r\n");
}


///////// HAR file export //////////////
Exporter.prototype.renderHar = function(requests) {

    if (requests.length < 1) return;

    var pages = [];
    var entries = [];
    var requestId = 0;
    for (var i = 0; i < requests.length; i++) {
        var obj = requests[i];
        var postData = null;
        var requestHeaders = [];
        var responseHeaders = [];
        var requestHeaderSize = 0;
        var responseHeaderSize = 0;
        if (obj.response && obj.response.requestHeaders) {
            requestHeaders = Object.keys(obj.response.requestHeaders).map(name => ({ name, value: obj.response.requestHeaders[name] }));
            requestHeaderSize = obj.response.requestHeadersText.length;
        } else if (obj.request && obj.request.headers) {
            requestHeaders = Object.keys(obj.request.headers).map(name => ({ name, value: obj.request.headers[name] }));
            Object.keys(obj.request.headers).map(name => (requestHeaderSize += name.length + obj.request.headers[name].length));
        }
        if (obj.response && obj.response.headers) {
            responseHeaders = Object.keys(obj.response.headers).map(name => ({ name, value: obj.response.headers[name] }));
        }



        if (obj.type == "Document" && requestId != obj.requestId) {
            var page = {
                "startedDateTime": (new Date(obj.wallTime).toISOString()),
                "id": obj.requestId,
                "title": obj.request.url,
                "pageTimings": {
                    "onContentLoad": -1,
                    "onLoad": -1
                }
            };
            pages.push(page);
            requestId = obj.requestId;
        }

        var cookies = [];
        if (obj.response.requestHeaders && obj.response.requestHeaders['Cookie']) {
            var cookieObject = {};
            obj.response.requestHeaders['Cookie'].split('; ').reduce(function(result, v, i, a) {
                var k = v.split('=');
                cookies.push({ "name": k[0], "value": k[1], "expires": null, "httpOnly": false, "secure": false });
            }, {});
        }

        if (obj.request.postData) {
            postData = {};
            postData.mimeType = obj.request.headers['Content-Type'];
            postData.text = obj.request.postData;
            var postArray = JSON.parse('{"' + decodeURI(obj.request.postData).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
            postData.params = Object.keys(postArray).map(name => ({ name, value: postArray[name] }));
        }

        var entry = {
            "startedDateTime": (new Date(obj.wallTime).toISOString()),
            "time": 204.2114249991181,
            "request": {
                "method": obj.request.method,
                "url": obj.request.url,
                "httpVersion": (obj.response &&  obj.response.protocol) ? obj.response.protocol.toUpperCase() : "HTTP/1.1",
                "headers": requestHeaders,
                "queryString": [],
                "cookies": cookies,
                "headersSize": requestHeaderSize,
                "bodySize": 0
            },
            "response": {
                "status": obj.response.status,
                "statusText": obj.response.statusText,
                "httpVersion": obj.response.protocol ? obj.response.protocol.toUpperCase() : "HTTP/1.1",
                "headers": responseHeaders,
                "cookies": [],
                "content": {
                    "size": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body.length : 0,
                    "mimeType": obj.response.mimeType,
                    "compression": 0,
                    "text": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body : "",
                    "encoding": (obj.responseBody && obj.responseBody.base64Encoded) ? "base64" : ""
                },
                "redirectURL": "",
                "headersSize": (obj.response.headersText ? obj.response.headersText.length : 0),
                "bodySize": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body.length : 0
            },
            "cache": {},
            "timings": {
                "send": -1,
                "receive": -1,
                "wait": -1
            },
            "serverIPAddress": obj.response.remoteIPAddress,
            "pageref": obj.parentId
        };

        if (postData != null) {
            entry.request.postData = postData;
        }
        entries.push(entry);
    }


    return {
        "log": {
            "version": "1.0",
            "creator": {
                "name": "PenTestKit",
                "version": "1.0"
            },
            pages: pages.reverse(),
            entries: entries
        }
    };
}


var Exporter = new Exporter();