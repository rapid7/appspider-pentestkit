/* Author: Denis Podgurskii */
'use strict';
////////////////////////////////////
/* Tab */
////////////////////////////////////
/*
{frames: [ frameId: [requestId: [item: {request: object, response: object} ] ] ] }
*/

function Tab(tabId, params, type) {
    this.setParams = function(params, type) {
        if (typeof(params['frameId']) != 'undefined') {
            var frameId = params['frameId'];
            var requestId = params['requestId'];

            if (typeof(this.frames[frameId]) == 'undefined') {
                this.frames[frameId] = {};
                BackgroundProxy.Logger.log("Init frames", { frameId: frameId, requestId: requestId });
            }
            if (typeof(this.frames[frameId][requestId]) == 'undefined') {
                this.frames[frameId][requestId] = [];
            }
            var index = this.frames[frameId][requestId].length;
            if (type == 'start') {
                this.frames[frameId][requestId][index] = params;
                BackgroundProxy.Logger.log("Add new item for ", { frameId: frameId, requestId: requestId });
            } else {
                for (var p in params) {
                    if (this.frames[frameId][requestId][index - 1][p] == 'undefined' ||
                        this.frames[frameId][requestId][index - 1][p] != params[p]) {
                        this.frames[frameId][requestId][index - 1][p] = params[p];
                    }
                }
                BackgroundProxy.Logger.log("Updated params ", { params: params, frameId: frameId, requestId: requestId });
            }
        } else {
            for (var p in params) {
                this[p] = params[p];
                BackgroundProxy.Logger.log("Add or update param ", { p: params[p] });
            }
        }
    };

    this.tabId = tabId;
    this.frames = {};
    this.setParams(params, type);
}; //end Tab

////////////////////////////////////
/* Settings */
////////////////////////////////////

function Settings() {
    return {
        //Index page
        main: {
            general: {
                capture_all_requests: false,
                capture_responses: false,
                enable_logging: false,
            },
            proxy: {
                pac_protocol: "http://",
                pac_path: "",

                http_url: "",
                http_port: "",
                https_url: "",
                https_port: "",
                socks_url: "",
                socks_port: "",
                socks_type: 'socks5',

                username: "",
                password: "",

                bypass: '127.0.0.1/*, 192,168.0.1/*'
            },
            headers: {
                protocol: "HTTP/1.1",
                useragent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 OPR/38.0.2220.41",
                accept: "*/*",
                acceptcharset: "utf-8, iso-8859-1;q=0.5, *;q=0.1",
                acceptlanguage: "en-US,en;q=0.5",
                acceptencoding: "deflate, gzip;q=1.0, *;q=0.5",
                extraheaders: "",
                cookie: ""
            }
        },
        //Request builder settings
        requestbuilder: {
            proxy: {},
            headers: {}
        },
        //Headers page
        headers: {
            request: {},
            response: {}
        }
    };
}; //end Settings

////////////////////////////////////
/* Request */
////////////////////////////////////

function Request() {
    this.send = function(schema, success, error) {

        var xhr = new XMLHttpRequest();

        //TODO set proxy
        var url = schema.uri.protocol + '://' + schema.uri.url + ((schema.uri.port != "80" && schema.uri.port != "443") ? (":" + schema.uri.port) : "") + schema.uri.path;
        if (schema.uri.queryString) url += schema.uri.queryString;
        try {
            xhr.open(
                schema.request.method,
                url,
                true
            );

        } catch (e) {
            BackgroundProxy.Logger.log(e);
        }

        BackgroundProxy.Logger.log('Customizing http request headers');
        /* Request headers */
        for (var h in schema.request.headers) {
            if (schema.request.headers[h].key) {
                try {
                    BackgroundProxy.Logger.log('Set header: ' + h + " : " + schema.request.headers[h].key);
                    xhr.setRequestHeader(schema.request.headers[h].key, schema.request.headers[h].value);
                } catch (e) {
                    BackgroundProxy.Logger.log('Invalid headers found !');
                }
            }
        }
        BackgroundProxy.Logger.log('Done setting custom headers!.');

        xhr.onreadystatechange = function() {
            if (xhr.status === 200) {
                switch (xhr.readyState) {
                    case 0:
                        BackgroundProxy.Logger.log('Request not yet initialized');
                        break;
                    case 1:
                        BackgroundProxy.Logger.log('Server connection established.');
                        break;
                    case 2:
                        BackgroundProxy.Logger.log('Request received');
                        break;
                    case 3:
                        BackgroundProxy.Logger.log('Processing request');
                        break;
                    case 4:
                        BackgroundProxy.Logger.log('Request finished and response is ready');
                        BackgroundProxy.Request.parseAttackResponse(schema.response, xhr);
                        success(schema);
                        break;
                    default:
                        error(schema);
                        console.error('Background.js: xhr.status: ' + xhr.status +
                            ' xhr.readyState: ' + xhr.readyState);
                        break;

                }
            } else {
                BackgroundProxy.Logger.log('Background.js - ' + xhr.status + ': Page not found');
                error(schema);
            }
            xhr.onerror = function(event) {
                console.error("Communication Error: Connection Refuse");
                error(schema);
            }
        };

        switch (schema.request.method.toUpperCase()) {
            case 'GET':
                BackgroundProxy.Logger.log('Sending request using GET XMLHTTPRequest');
                xhr.send();
                break;
            case 'POST':
                BackgroundProxy.Logger.log('Sending request using POST XMLHTTPRequest' + schema.request.body);
                xhr.send(schema.request.body);
                break;
            default:
                console.error('Background.js: Unable to send request');
                break;
        }
    };

    this.parseRequestString = function(requestStr, requestObject) {

        /* Start */
        var schema = this.schema();

        var requestData = requestStr.split(/\r?\n\r?\n/);
        var headerArray = requestData[0].split(/\r?\n/);

        var headers = [];
        for (var i = 0; i < headerArray.length; i++) {
            if (headerArray[i].toUpperCase().match(/(^GET|^POST|^PUT|^DELETE)/)) {
                var requestArray = headerArray[i].split(' ');
                schema.uri = this.parseUri(schema.uri, requestArray[1]);
                schema.request.method = requestArray[0].trim();
                schema.request.version = requestArray[2];
            } else if (headerArray[i].indexOf(':') > -1) {
                var a = headerArray[i].split(':');
                var header_name = a[0].trim();
                switch (header_name.toLowerCase()) {
                    case 'referer':
                        headers.push({
                            key: 'Referer',
                            value: a.slice(1).join(':').trim()
                        });
                        break;
                    case 'cookie':
                        var cookiearray = a[a.length - 1].split(';');
                        var cookies = [];
                        for (var x = 0; x < cookiearray.length; x++) {
                            if (cookiearray[x].indexOf('=') > -1) {
                                var array = cookiearray[x].split('=');
                                var key = array[0].trim();
                                var value = array[array.length - 1].trim();
                                cookies.push({
                                    key: key,
                                    value: value
                                });
                            }
                        }
                        schema.request.cookie = cookies;
                        break;
                    case 'host':
                        if (a.length == 3) {
                            schema.uri.port = a[a.length - 1].trim();
                            schema.uri.url = a[a.length - 2].trim()
                        } else if (a.length == 2) {
                            schema.uri.url = a[a.length - 1].trim()
                        }
                        var h = schema.uri.port != '' ? schema.uri.url + ":" + schema.uri.port : schema.uri.url;
                        headers.push({
                            key: 'Host',
                            value: h
                        });
                        break;
                    default:
                        headers.push({
                            key: header_name,
                            value: a[a.length - 1].trim()
                        });
                        break;
                }
            }
        }
        schema.request.headers = headers;
        if (requestObject) {
            schema.request.method = requestObject.request_method;
            schema.uri.protocol = requestObject.request_protocol;
            schema.uri.url = requestObject.request_url;
            schema.uri.port = requestObject.request_port;
        }
        if(requestData.length > 1) {
            BackgroundProxy.Logger.log(requestData);
            schema.request.body = requestData[1];
        }
        /* End */
        return schema;

    };

    this.parseAttackResponse = function(responseSchema, xhr) {
        var headerString = xhr.getAllResponseHeaders();
        var headerArray = headerString.split('\r\n');
        var headers = [];
        var content = xhr.responseText;
        BackgroundProxy.Logger.log(xhr);
        for (var i = 0; i < headerArray.length; i++) {
            var a = headerArray[i].split(':');
            if (a[0].trim() !== '') {
                headers.push({
                    key: a[0].trim(),
                    value: a[1].trim()
                });
            }
        }
        responseSchema.headers = headers;
        responseSchema.content = content;
        return responseSchema;
    };

    this.parseUri = function(uriSchema, unparsedUri) {
        if (unparsedUri.indexOf('?') > 0) {
            uriSchema.path = unparsedUri.substring(0, unparsedUri.indexOf('?'));
            uriSchema.parameters = this.parseQueryString(unparsedUri.substring(unparsedUri.indexOf('?') + 1));
            uriSchema.queryString = unparsedUri.substring(unparsedUri.indexOf('?'));
        } else {
            uriSchema.parameters = [];
            uriSchema.path = unparsedUri;
        }
        return uriSchema;
    };

    this.parseQueryString = function(queryString) {
        if (queryString.indexOf('?') === 0) {
            queryString = queryString.slice(1);
        }
        var parameters = [];
        var queryArray = queryString.split('&');
        for (var index in queryArray) {
            if (queryArray.hasOwnProperty(index)) {
                parameters.push({
                    key: queryArray[index].split('=')[0],
                    value: queryArray[index].split('=')[1]
                });
            }
        }
        return parameters;
    };

    this.schema = function() {
        return {
            request: function() {
                return {
                    headers: [],
                    body: '',
                    cookie: [],
                    uri: this.schema.uri(),
                    method: '',
                    version: ''
                }
            },
            response: function() {
                return {
                    headers: 'Waiting for attack response....(click the ' +
                        'Send request button if response is taking a while)',
                    content: ''
                }
            },
            uri: function() {
                return {
                    parameters: [],
                    protocol: 'http',
                    url: '',
                    path: '',
                    queryString: '',
                    port: ''
                }
            }
        }
    };
}; //end Request

////////////////////////////////////
/* Utils */
////////////////////////////////////

function Utils() {
    this.jsonPathToValue = function(jsonData, path) {
        if (!(jsonData instanceof Object) || typeof(path) === "undefined") {
            throw "Not valid argument:jsonData:" + jsonData + ", path:" + path;
        }
        path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        path = path.replace(/^\./, ''); // strip a leading dot
        var pathArray = path.split('.');
        for (var i = 0, n = pathArray.length; i < n; ++i) {
            var key = pathArray[i];
            if (key in jsonData) {
                if (jsonData[key] !== null) {
                    jsonData = jsonData[key];
                } else {
                    return null;
                }
            } else {
                return key;
            }
        }
        return jsonData;
    };

    this.jsonSetValueByPath = function(jsonData, path, value) {
        if (!(jsonData instanceof Object) || typeof(path) === "undefined") {
            throw "Not valid argument:jsonData:" + jsonData + ", path:" + path;
        }
        var origData = jsonData;
        path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        path = path.replace(/^\./, ''); // strip a leading dot
        var pathArray = path.split('.');
        var i = 0;
        do {
            var key = pathArray[i];
            if (key in jsonData) {
                if (i < (pathArray.length - 1))
                    jsonData = jsonData[key];
                else
                    jsonData[key] = value;

            }
            i++;
        } while (i < pathArray.length)
        return origData;
    };
}; //end Utils

////////////////////////////////////
/* Logger */
////////////////////////////////////

function Logger() {
    this.log = function(event, msg, level) {
        if (BackgroundProxy.settings != null && BackgroundProxy.settings.main.general.enable_logging) {
            console.log("---------" + event + "---------");
            if (msg instanceof Array) {
                for (m in msg) {
                    console.log(m + ": " + msg[m]);
                }
            } else console.log(msg);
            console.log("Logged at: " + Date.now());
        }
    };

}; //end Logger


////////////////////////////////////
/* XHeaders */
////////////////////////////////////
/*
{request: [ {header_name: "", header_value: "", matchstring: "", operation: "equals", part: "url", type: "add"} ] ,
 response:  [ {header_name: "", header_value: "", matchstring: "", operation: "equals", part: "url", type: "add"} ]}
*/
function eXHeaders() {
    this.headers = [];
    this.add = function(type, obj) {

        chrome.storage.local.get('pentestkit_headers', function(result) {
            var arHeaders = { request: [], response: [] };
            if (result.pentestkit_headers) {
                arHeaders = result.pentestkit_headers;
            }
            if (type == 'request') {
                arHeaders.request[arHeaders.request.length] = obj;
            } else {
                arHeaders.response[arHeaders.response.length] = obj;
            }
            BackgroundProxy.eXHeaders.headers = arHeaders;
            chrome.storage.local.set({ 'pentestkit_headers': arHeaders });
        });

    };

    this.clean = function(item) {
        chrome.storage.local.get('pentestkit_headers', function(result) {
            var arHeaders = { request: [], response: [] };
            if (result.pentestkit_headers) {
                arHeaders = result.pentestkit_headers;
            }
            if (item.type == 'request') {
                arHeaders.request = [];
            } else {
                arHeaders.response = [];
            }
            BackgroundProxy.eXHeaders.headers = arHeaders;
            chrome.storage.local.set({ 'pentestkit_headers': arHeaders });
        });
    };

    this.remove = function(item) {
        chrome.storage.local.get('pentestkit_headers', function(result) {
            if (!result.pentestkit_headers) return;
            if (item.type == 'request') {
                result.pentestkit_headers.request.splice(item.index, 1);
            } else {
                result.pentestkit_headers.response.splice(item.index);
            }
            BackgroundProxy.eXHeaders.headers = result.pentestkit_headers;
            chrome.storage.local.set({ 'pentestkit_headers': result.pentestkit_headers });
        });
    };

    this.getHeaders = function() {
        return BackgroundProxy.eXHeaders.headers;
    };

}; //end XHeaders