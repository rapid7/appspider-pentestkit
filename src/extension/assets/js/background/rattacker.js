/* Author: Denis Podgurskii */
import { ptk_SqlInjection } from "../modules/active/SqlInjection.js"
import { ptk_XSS } from "../modules/active/xss.js"
import { ptk_OSCommand } from "../modules/active/oscommand.js"
import { ptk_request } from "./request.js"
import { ptk_utils, ptk_logger } from "./utils.js"

export class ptk_rattacker {

    constructor() {
        this.attackModules = {
            SqlInjection: new ptk_SqlInjection(),
            XSS: new ptk_XSS(),
            OSCommand: new ptk_OSCommand()
        }
    }

    init(request) {
        this.scanResult = {
            items: [],
            request: request,
            stats: {
                vulnsCount: 0,
                attacksCount: 0
            }
        }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_rattacker") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_init(message) {
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_reset(message) {
        this.init()
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_run_scan(message) {
        let scanId = ptk_utils.UUID()
        this.runScan(scanId, message.schema)
        return Promise.resolve({ success: true, result: scanId })
    }

    async runScan(scanId, schema) {
        let request = new ptk_request()
        this.init(request.toString(schema))

        for (let key in this.attackModules) {
            let module = this.attackModules[key]
            for (let attackIndex in module.attacks) {
                let attack = module.attacks[attackIndex]
                if (attack.methods.includes(schema.request.method)) {
                    let modifiedSchema = JSON.parse(JSON.stringify(schema))
                    attack = module.prepareAttack(attack, ptk_utils.attackId())
                    
                    if (["POST", "PUT", "DELETE", "PATCH"].includes(modifiedSchema.request.method)) {
                        modifiedSchema = this.modifyPostParams(modifiedSchema, attack.options)
                    }
                    let url = new URL(modifiedSchema.request.url)
                    if (url.search) {
                        modifiedSchema = this.modifyGetParams(modifiedSchema, attack.options)
                    }

                    modifiedSchema.asString = request.toString(modifiedSchema)
                    let vulnRegex = attack.options.vulnRegex ? attack.options.vulnRegex : module.vulnRegex
                    await this.runAttack(scanId, modifiedSchema, attack, vulnRegex)
                }
            }
        }
    }

    modifyPostParams(modifiedSchema, options) {
        let params = modifiedSchema.request.body.split('&')
        for (let i in params) {
            params[i] = options.position == 'before' ? params[i].replace('=', '=' + options.attackValue) : params[i] + options.attackValue
        }
        modifiedSchema.request.body = params.join('&')
        return modifiedSchema
    }

    modifyGetParams(modifiedSchema, options) {
        let url = new URL(modifiedSchema.request.url)
        for (const [key, value] of url.searchParams) {
            let v = options.position === 'before' ? options.attackValue + value : value + options.attackValue
            url.searchParams.set(key, v)
        }
        modifiedSchema.request.url = url.toString()
        return modifiedSchema
    }

    runAttack(scanId, schema, attack, vulnRegex) {
        let request = new ptk_request()
        schema.request.followRedirect = true
        return request.sendRequest(schema).then((result) => {
            let body = result.body, re = new RegExp(vulnRegex)
            let item = {
                attack: attack,
                request: btoa(request.toString(schema)),
                baseUrl: schema.request.url,
                body: btoa(body),
                headers: btoa(result.headers)
            }

            this.scanResult.stats.attacksCount++
            if (re.test(body)) {
                item.success = true
                item.proof = btoa(body.match(re)[0])
                this.scanResult.stats.vulnsCount++
                console.log("match found")
            } else {
                item.success = false
                item.proof = ""
                console.log("match NOT found")
            }
            this.scanResult.items.push(item)
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_rattacker",
                type: "attack completed",
                info: item,
                scanResult: this.scanResult
            }).catch(e =>
                ptk_logger.log(e, "Could not send a message", "info")
            )
        }).catch(function (error) {
            ptk_logger.log(e, "Could not run an attack", "info")
        })
    }

}
