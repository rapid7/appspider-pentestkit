/* Author: Denis Podgurskii */
import { Wappalyzer } from "../packages/wappalyzer/wappalyzer.js"
import { HttpHeadersCheck } from "../modules/passive/headers.js"


export class ptk_dashboard {
    constructor() {

        this.Wappalyzer = Wappalyzer

        fetch(chrome.runtime.getURL('ptk/packages/wappalyzer/technologies.json'))
            .then(response => response.json())
            .then(data => {
                this.technologies = data.technologies
                this.categories = data.categories
            })

        fetch(chrome.runtime.getURL('ptk/background/waf.json'))
            .then(response => response.json())
            .then(data => {
                this.wafTechnologies = data.technologies
                this.wafCategories = data.categories
            })

        this.addMessageListiners()
    }

    async initCookies(domains) {

        let cookies = {}
        for (let i = 0; i < domains.length; i++) {
            await browser.cookies.getAll({ 'domain': domains[i] }).then(function (cookie) { cookies[domains[i]] = cookie })
        }

        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "init_complete",
            data: Object.assign({},  { cookies: cookies })
        })

        return Promise.resolve()
    }

    async analyzeTab(message) {
        this.Wappalyzer.setTechnologies(this.technologies)
        this.Wappalyzer.setCategories(this.categories)

        let detections = this.Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html
        })

        let technologies = Array.prototype.concat.apply(
            [],
            message.info.dom.map(({ name, selector, text, property, attribute, value }) => {
                const technology = this.Wappalyzer.technologies.find(({ name: _name }) => name === _name)

                if (text) {
                    return this.Wappalyzer.analyzeManyToMany(technology, 'dom.text', { [selector]: [text], })
                }

                if (property) {
                    return this.Wappalyzer.analyzeManyToMany(technology, `dom.properties.${property}`, { [selector]: [value], })
                }

                if (attribute) {
                    return this.Wappalyzer.analyzeManyToMany(technology, `dom.attributes.${attribute}`, { [selector]: [value], })
                }

                return []
            })
        )
        technologies = technologies.map(item => { return { name: item.technology.name, version: item.version ? item.version : "" } })
        technologies = Array.prototype.concat.apply(technologies, this.Wappalyzer.resolve(detections))

        //WAF
        this.Wappalyzer.setTechnologies(this.wafTechnologies)
        this.Wappalyzer.setCategories(this.wafCategories)

        let wafDetections = this.Wappalyzer.analyze({
            headers: this.tab.responseHeaders,
            meta: message.info.meta,
            scripts: message.info.scripts,
            html: message.info.html
        })
        let wafTechnologies = this.Wappalyzer.resolve(wafDetections)


        browser.runtime.sendMessage({
            channel: "ptk_background2popup_dashboard",
            type: "analyze_complete",
            data: Object.assign({}, { technologies: technologies, waf: wafTechnologies })
        })

        return Promise.resolve()
    }



    /* Listeners */

    addMessageListiners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {

        if (message.channel == "ptk_popup2background_dashboard") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve()
        }
    }

    async msg_init(message, tab) {

        this.activeTab = window.ptk_app.proxy.activeTab

        this.Wappalyzer.setTechnologies(this.technologies)
        this.Wappalyzer.setCategories(this.categories)

        this.wappalyzerDomRules = this.Wappalyzer.technologies
            .filter(({ dom }) => dom)
            .map(({ name, dom }) => ({ name, dom }))
            .filter(item => item.dom != "")

        this.wappalyzerJsRules = this.Wappalyzer.technologies
            .filter(({ js }) => js)
            .map(({ name, js }) => ({ name, js }))
            .filter(item => item.js != "")

        if (window.ptk_app.proxy.isTabsCapturingActive && this.activeTab?.tabId) {

            setTimeout(() => {
                
                browser.tabs.sendMessage(this.activeTab.tabId, {
                    channel: "ptk_background2content",
                    type: "init",
                    dom: this.wappalyzerDomRules,
                    js: this.wappalyzerJsRules
                }).catch(() => { })
            }, 50)

            let tab = window.ptk_app.proxy.getTab(this.activeTab.tabId)
            let self = this
            return tab?.analyze().then(function (result) {
                self['tab'] = result
                let findings = HttpHeadersCheck.checkSecurityHeaders(tab)
                self.initCookies(result.domains)

                return Promise.resolve(Object.assign({}, result, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive, findings: findings }))
                // browser.runtime.sendMessage({
                //     channel: "ptk_background2popup_dashboard",
                //     type: "init_complete",
                //     data: Object.assign({}, result, { findings: findings, cookies: cookies })
                // })
            })

        }

        return Promise.resolve(Object.assign({}, window.ptk_app.proxy.activeTab, { proxyOn: window.ptk_app.proxy.isTabsCapturingActive }))
    }


    msg_analyze(message, tab) {
        if (!this.tab) return
        this.analyzeTab(message)
        return Promise.resolve()
    }

    /* End Listeners */
}