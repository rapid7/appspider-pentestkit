/* Author: Denis Podgurskii */
import { ptk_sqlinjection } from "../modules/active/sqlinjection.js"
import { ptk_xss } from "../modules/active/xss.js"
import { ptk_oscommand } from "../modules/active/oscommand.js"
import { ptk_request } from "../../npm/background/request.js"
import { ptk_utils, ptk_logger, ptk_queue } from "../../npm/background/utils.js"

export class ptk_rattacker {

    constructor() {
        this.reset()
        this.attackModules = {
            SqlInjection: new ptk_sqlinjection(),
            XSS: new ptk_xss(),
            OSCommand: new ptk_oscommand()
        }
    }

    reset() {
        this.scanResult = {
            scanId: null,
            tabId: null,
            host: null,
            uniqueRequestQueue: new ptk_queue(),
            requestQueue: new ptk_queue(),
            items: {},
            stats: {
                vulnsCount: 0,
                attacksCount: 0
            },
            settings: {}
        }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    addListeners() {
        this.onRemoved = this.onRemoved.bind(this)
        browser.tabs.onRemoved.addListener(this.onRemoved)

        this.onCompleted = this.onCompleted.bind(this)
        browser.webRequest.onCompleted.addListener(
            this.onCompleted,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    removeListeners() {
        browser.tabs.onRemoved.removeListener(this.onRemoved)
        browser.webRequest.onCompleted.removeListener(this.onCompleted)
    }

    onRemoved(tabId, info) {
        if (this.scanResult?.tabId == tabId) this.scanResult.tabId = null
    }

    onCompleted(response) {
        if (this.scanResult?.tabId == response.tabId) {
            let r = window.ptk_app.tabs.getRawRequest(window.ptk_app.tabs.getTab(response.tabId), response.frameId, response.requestId)
            this.addRequest(r)
        }
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_rattacker") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_init(message) {
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_reset(message) {
        this.reset()
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_run_scan(message) {
        this.reset()
        this.scanResult.scanId = ptk_utils.UUID()
        this.runAllAttacks(message.schema)
        return Promise.resolve({ success: true })
    }

    msg_run_bg_scan(message) {
        this.runBackroungScan(message.tabId, message.host)
        return Promise.resolve({ success: true, scanResult: this.scanResult })
    }

    msg_stop_bg_scan(message) {
        this.stopBackroungScan()
        return Promise.resolve({ success: true, scanResult: this.scanResult })
    }


    runBackroungScan(tabId, host) {
        this.reset()
        this.scanResult.scanId = ptk_utils.UUID()
        this.scanResult.tabId = tabId
        this.scanResult.host = host
        this.scan()
        this.addListeners()
    }

    stopBackroungScan() {
        this.scanResult.tabId = null
        this.scanResult.requestQueue.clear()
        this.removeListeners()
    }

    addRequest(item) {
        let url = item.split('\n')[0]
        if(!this.scanResult.uniqueRequestQueue.has(url)){
            this.scanResult.uniqueRequestQueue.enqueue(url)
            this.scanResult.requestQueue.enqueue(item)
        }
    }

    async scan() {
        if (!this.scanResult.tabId) return
        let ptkRequest = new ptk_request({ "base": "" })

        while (this.scanResult.requestQueue.size()) {
            let item = this.scanResult.requestQueue.dequeue()
            let schema = ptkRequest.parseRawRequest({ request: item })
            this.runAllAttacks(schema)
        }

        let self = this
        setTimeout(function () { self.scan() }, 1000)
    }

    async runAllAttacks(schema) {
        let request = new ptk_request({ "base": "" })
        let attackId = ptk_utils.attackId()
        this.scanResult.items[attackId] = {}
        this.scanResult.items[attackId]['originalSchema'] = request.toString(schema)
        this.scanResult.items[attackId]['originalUrl'] = schema.request.url
        this.scanResult.items[attackId]['attacks'] = []

        for (let key in this.attackModules) {
            let module = this.attackModules[key]
            for (let attackIndex in module.attacks) {
                let attack = module.attacks[attackIndex]
                if (attack.methods.includes(schema.request.method)) {
                    let modifiedSchema = JSON.parse(JSON.stringify(schema))
                    attack = module.prepareAttack(attack, ptk_utils.attackId())

                    if (["POST", "PUT", "DELETE", "PATCH"].includes(modifiedSchema.request.method)) {
                        modifiedSchema = this.modifyPostParams(modifiedSchema, attack.options)
                    }
                    let url = new URL(modifiedSchema.request.url)
                    if (url.search) {
                        modifiedSchema = this.modifyGetParams(modifiedSchema, attack.options)
                    }

                    modifiedSchema.asString = request.toString(modifiedSchema)
                    let vulnRegex = attack.options.vulnRegex ? attack.options.vulnRegex : module.vulnRegex
                    let item = await this.runAttack(modifiedSchema, attack, vulnRegex)
                    try {
                        this.scanResult.items[attackId]['attacks'].push(JSON.parse(JSON.stringify(item)))
                    } catch (e) {
                        console.error(e)
                    }
                }
            }
        }
        if (!this.scanResult.requestQueue.size()) {
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_rattacker",
                type: "all attacks completed",
                scanResult: this.scanResult
            }).catch(e => ptk_logger.log(e, "Could not send a message", "info"))
        }
    }

    modifyPostParams(modifiedSchema, options) {
        let params = modifiedSchema.request.body.split('&')
        for (let i in params) {
            params[i] = options.position == 'before' ? params[i].replace('=', '=' + options.attackValue) : params[i] + options.attackValue
        }
        modifiedSchema.request.body = params.join('&')
        return modifiedSchema
    }

    modifyGetParams(modifiedSchema, options) {
        let url = new URL(modifiedSchema.request.url)
        for (const [key, value] of url.searchParams) {
            let v = options.position === 'before' ? options.attackValue + value : value + options.attackValue
            url.searchParams.set(key, v)
        }
        modifiedSchema.request.url = url.toString()
        return modifiedSchema
    }

    async runAttack(schema, attack, vulnRegex) {
        let request = new ptk_request({ "base": "" })
        schema.request.followRedirect = true
        let item = {
            attack: attack,
            request: btoa(request.toString(schema)),
            baseUrl: schema.request.url,
            body: "",
            headers: "",
            failed: false
        }

        try {
            this.scanResult.stats.attacksCount++
            const result = await request.sendRequest(schema)
            let body = result.body, re = new RegExp(vulnRegex)
            item.body = body ? btoa(body) : ""
            item.headers = btoa(result.headers)

            if (re.test(body)) {
                item.success = true
                item.proof = btoa(body.match(re)[0])
                this.scanResult.stats.vulnsCount++
                console.log("match found")
            } else {
                item.success = false
                item.proof = ""
                console.log("match NOT found")
            }

            browser.runtime.sendMessage({
                channel: "ptk_background2popup_rattacker",
                type: "attack completed",
                info: item,
                scanResult: this.scanResult
            }).catch(e => ptk_logger.log(e, "Could not send a message", "info"))
            return item
        } catch (error) {
            ptk_logger.log(error, "Could not run an attack", "info")
            item.failed = true
            return item
        }
    }

}
